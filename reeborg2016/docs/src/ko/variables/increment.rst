증가
=========

.. todo::

    프로그램을 재작성하고 **Storm 1** 세상을 예제로 사용한다; ``carries_object()`` 함수를 비활성화 시키고, 대신에 리보그로 하여금 낙엽 갯수를 세게 만든다.

    글로벌 키워드(global keyword)를 도입한다.


세상 **Around 1** 를 선택한다.

시작지점에서부터 리보그가 오른쪽 벽을 향해서 도착할 때까지 얼마나 걸음을 걸었는지 세고자 한다고 가정하자.
이 작업을 수행하는 한 방법이 ``number_of_steps`` 라는 변수를 생성하고, 초기값을 0으로 설정한다.
그리고 나서, 리보그가 걸음을 걸을 때마다, ``number_of_steps`` 변수의 *이전* 값에 1을 추가한다.

너무 간단한가요?

저자가 상기 작업만 수행하는 프로그램을 작성하기 전에, 실험을 간단히 해보자.

.. topic:: 시도해 보기!

    다음 프로그램을 실행한다::

        n = 1
        n = n + 3
        print(n)

    출력되는 값이 무엇인가요? 그리고 나서 다음을 실행해본다::

        a = a + 3
        print(a)


변수와 할당 연산자 ``=`` 를 공부했을 때를 상기한다.
변수는 객체에 부여된 명칭으로,
부여된 명칭으로 참조할 수 있다. 기본 형태는 다음과 같다::

    변수 = 객체
    # variable = object

앞에서 살펴본 예제는 다음과 같다::

    length = 4
    width = 6
    area = length * width  # 직사각형 면적
    print(area)            # 출력결과 24

객체 ``area`` 가 참조하는 것을 해결하려면, 파이썬에서 ``length`` 와 ``width`` 변수를 변수가 참조하는 객체로 치환한다::

    area = 4 * 6

하지만, ``4 * 6`` 는 여전히 객체는 아니다: 두 객체의 곱이다.
그래서, 파이썬이 좀더 작업을 해서 다음 결과를 얻게 된다::

    area = 24

이제, 할당 연산자 ``=`` 왼편에 (변수) 명칭과 우측편에 객체 (``24``)를 갖는 방정식을 생성하게 되었다. 이전 예제로 되돌아가자::

    n = 1
    n = n + 3

동일한 변수명 ``n`` 이 할당 연산자 양쪽에 나타난다고 로직이 변경되지는 않는다: 어떤 **단일** 객체도 오른쪽 편에 있는 것을 먼저 알아낸다. 그리고 나서, 변수에 할당한다. 따라서, 다음 코드는::

    n = 1

파이썬에게 언제든 ``n`` 을 적을 때마다, 변수 ``n`` 이 값으로 ``1`` 을 의미하게 된다. 다음줄에 다른 코드가 나와 있다::

    n = n + 3

분명하게 표준 수학 연산은 아니다! 방금전에 살펴봤듯이, 할당 연산자는 파이썬으로 하여금 객체에 새로운 명칭을 할당하게 함을 기억하라. 여기서 객체는 다음 표현식을 경유해서 얻어진다::

    n + 3

앞에서 파이썬에게 ``n`` 은 ``1`` 을 나타낸다고 일러줬다. 따라서, ``n+3`` 은 ``1+3`` 으로 간주되어야만 한다.
파이썬은 정수를 더하는 방법을 알고 있어서, 두 정수의 합을 단일 정수로 치환할 수 있다: ``4``. 따라서, ``n+3`` 은 객체 ``4`` 를 나타내고 , 다음 줄에 나온 코드는::

    n = n + 3

실제로 의미하는 것은 다음과 같다::

    n = 4

그리고, 상기 코드라인은 파이썬에게 다음과 같이 일러주는 것으로 간주할 수 있다: *이전에 ``n`` 값이 무엇을 의미했던지,
잊어버리고, 이제부터는 ``4`` 를 의미하는 것으로 간주한다.*

``a = a + 3`` 은 어떤가? 파이썬은 먼저 ``a + 3`` 우측편을 살펴보는데, 변수 ``a`` 는 이전에 어떤 객체도 할당된 적이 없다.
그래서, 어떤 작업을 수행해야 하는지 알지 못하게 된다.

.. topic:: 걸음수 세기

    **Around 1** 세상에서 벽을 마주칠 때까지 리보그가 필요한 걸음수를 셀 시점이다. 걸음수 세는 작업이 다음 프로그램에 나와 있다::

        number_of_steps = 0

        while front_is_clear():
            number_of_steps = number_of_steps + 1
            move()

        print(number_of_steps)

.. topic:: 여러분 차례

    리보그가 **Around 1** 세상을 쭉 따라 돌게 만든다.
    세상을 돌아다니면서, 리보그가 걸은 걸음걸이 횟수와 왼쪽으로 회전한 횟수를 세고, 마지막에 걸음걸이 횟수와 좌회전한 횟수를 출력한다.
 

.. hint::

    .. code-block:: py3

        number_of_steps = 0
        number_of_turns = 0
        
        think(10)
        
        while not wall_in_front():    
            move()
    
            if wall_in_front():
                turn_left()
                number_of_turns = number_of_turns + 1
            number_of_steps = number_of_steps + 1
    
            if number_of_turns == 4:
                print(number_of_steps)
                print(number_of_turns)
                done()



증강 할당 연산자
------------------------------

.. index:: augmented assignment operators
.. index:: 증강된 할당 연산자

.. index:: +=, -=, /=, *=, //=, **=

파이썬 프로그램에서, 다음과 같은 것을 수행할 필요가 종종 있다::

    number_of_steps = number_of_steps + 1

혹은::

    pizza_slices = pizza_slices - 1

상기 할당 연산자는 작성하기도 길지만, **되풀이 반복하지 마세요!** 라는 규칙 #3을 지키지도 않는데, 이유는 같은 행에 동일한 변수명이 **두번** 작성되기 때문이다.
그러한 코드 반복을 회피하도록 작성하는 더 간략한 방법이 있다. 통상  **증강 할당 연산자(augmented assignment operators)** 라고 부른다.

상기 코드를 다음과 같이 다시 작성할 수 있다::

    number_of_steps += 1
    pizza_slices -= 1

각 수학 연산자(``+, -, /, //, *, **``)마다, 상응하는 증강 할당 연산자(``+=, -=, /=, //=, *=, **=``)가 있다. 

.. important::

   증강 할당 연산자를 사용할 때, 기호 사이에 공백을 넣으면 안된다. 따라서, ``+=`` 은 되지만, ``+  =`` 처럼 공백이 있으면 안된다.

.. topic:: 여러분 차례

    리보그가 **Around 1** 세상을 쭉 따라 돌게 만든다.
    세상을 돌아다니면서, 리보그가 걸은 걸음걸이 횟수와 왼쪽으로 회전한 횟수를 세고, 마지막에 걸음걸이 횟수와 좌회전한 횟수를 출력한다. 이번에는 증강 할당 연산자를 사용한다.


비교 연산자
--------------------

객체를 비교하는 것이 때때로 매우 도움이 된다.
숫자로 시작해본다.

.. topic:: 시도해 보기!

    .. code-block:: py3

        print( 2 == 2)  # 숫자 두개가 같다.
        print( 2 == 3)

        print( 2 != 2)  # 숫자 두개가 다르다.
        print( 2 != 3)


정원 작업으로 되돌아 간다
--------------------------------------

이전 학습 말미에, ``carries_object()`` 함수를 사용할 수 없기 때문에, 리보그가 작업을 마무리 할 수 없게 되었다. 하지만, 모은 낙엽 갯수를 기록하는 방법을 이제 알게 되었기 때문에, 얼마나 많이 놓을지도 알 수 있게 되었다.
